This repository includes my work from CS 320: Software Testing, Automation, and Quality Assurance. These projects really challenged me to think differently about how software is built and tested. Even though some parts were overwhelming at first, working through the process helped me gain a stronger understanding of how testing and automation support quality software development.

Included Files: 

Contact.java

ContactService.java

ContactTest.java

ContactServiceTest.java

Project Two Summary and Reflections Report

How can I ensure that my code, program, or software is functional and secure?

Making sure my code works correctly took a lot of trial and error. At first, I thought just running the program was enough, but I learned that real testing means going deeper—writing unit tests and checking every method for possible failures. JUnit testing was tough to get used to, but once I understood how to write tests that intentionally try to break my code, I could catch mistakes early. For security, I learned to validate inputs and handle exceptions so the program wouldn’t crash or expose bad data. It wasn’t easy, but I started to see how careful testing builds confidence in my code.

How do I interpret user needs and incorporate them into a program?

Understanding user needs can be tricky because sometimes the requirements feel vague at first. I had to step back and think about what the user actually wants the program to do, not just what I want it to do. In the Contact Service project, for example, I had to make sure each contact was unique and handled properly if the user entered bad information. Thinking from the user’s point of view helped me decide how the code should respond to errors or missing data. That mindset made a big difference in how I approached development.

How do I approach designing software?

Designing software felt overwhelming at first because there are so many details to think about before even writing code. I learned to start small—planning out one piece at a time and using object-oriented design to keep things organized. I also learned that testing early helps guide the design process. When I ran into problems, it taught me how important structure and naming conventions are for keeping code clear. Even though I struggled at times, finishing these projects helped me see how design, testing, and debugging all connect to make a complete, working program.
